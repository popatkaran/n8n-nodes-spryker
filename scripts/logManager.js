#!/usr/bin/env node

/**
 * Spryker API Log Manager
 * 
 * This utility script helps manage Spryker API logs generated by the n8n node.
 * 
 * Usage:
 *   node scripts/logManager.js [command] [options]
 * 
 * Commands:
 *   stats                    - Show logging statistics
 *   list                     - List all log files
 *   view [file]              - View log entries from a specific file
 *   search [criteria]        - Search logs by criteria
 *   cleanup [days]           - Clean up logs older than specified days
 *   export [format] [file]   - Export logs to different formats
 */

const fs = require('fs');
const path = require('path');

class LogManager {
	constructor() {
		this.projectRoot = this.findProjectRoot();
		this.logsDir = path.join(this.projectRoot, 'logs', 'spryker');
		this.ensureLogDirectory();
	}

	findProjectRoot() {
		let currentDir = __dirname;
		
		while (currentDir !== path.dirname(currentDir)) {
			const packageJsonPath = path.join(currentDir, 'package.json');
			if (fs.existsSync(packageJsonPath)) {
				return currentDir;
			}
			currentDir = path.dirname(currentDir);
		}
		
		return process.cwd();
	}

	ensureLogDirectory() {
		if (!fs.existsSync(this.logsDir)) {
			console.log(`Log directory not found: ${this.logsDir}`);
			console.log('No logs have been generated yet.');
			process.exit(0);
		}
	}

	getLogFiles() {
		try {
			return fs.readdirSync(this.logsDir)
				.filter(file => file.endsWith('.json'))
				.sort()
				.reverse(); // Most recent first
		} catch (error) {
			console.error('Failed to read log directory:', error.message);
			return [];
		}
	}

	readLogFile(fileName) {
		const filePath = path.join(this.logsDir, fileName);
		try {
			const content = fs.readFileSync(filePath, 'utf8');
			return content.split('\n')
				.filter(line => line.trim())
				.map(line => JSON.parse(line));
		} catch (error) {
			console.error(`Failed to read log file ${fileName}:`, error.message);
			return [];
		}
	}

	showStats() {
		const logFiles = this.getLogFiles();
		
		if (logFiles.length === 0) {
			console.log('No log files found.');
			return;
		}

		let totalEntries = 0;
		let totalSize = 0;
		let errorCount = 0;
		let operationCounts = {};
		let resourceCounts = {};

		console.log('\n📊 Spryker API Logging Statistics\n');
		console.log(`Log Directory: ${this.logsDir}`);
		console.log(`Total Log Files: ${logFiles.length}`);

		for (const file of logFiles) {
			const filePath = path.join(this.logsDir, file);
			const stats = fs.statSync(filePath);
			totalSize += stats.size;

			const entries = this.readLogFile(file);
			totalEntries += entries.length;

			for (const entry of entries) {
				if (entry.error) {
					errorCount++;
				}

				operationCounts[entry.operation] = (operationCounts[entry.operation] || 0) + 1;
				resourceCounts[entry.resource] = (resourceCounts[entry.resource] || 0) + 1;
			}
		}

		console.log(`Total Log Entries: ${totalEntries}`);
		console.log(`Total Size: ${this.formatBytes(totalSize)}`);
		console.log(`Error Count: ${errorCount}`);
		console.log(`Success Rate: ${((totalEntries - errorCount) / totalEntries * 100).toFixed(1)}%`);

		console.log('\n📈 Operations:');
		Object.entries(operationCounts)
			.sort(([,a], [,b]) => b - a)
			.forEach(([operation, count]) => {
				console.log(`  ${operation}: ${count}`);
			});

		console.log('\n📦 Resources:');
		Object.entries(resourceCounts)
			.sort(([,a], [,b]) => b - a)
			.forEach(([resource, count]) => {
				console.log(`  ${resource}: ${count}`);
			});

		console.log('\n📁 Log Files:');
		logFiles.forEach(file => {
			const filePath = path.join(this.logsDir, file);
			const stats = fs.statSync(filePath);
			const entries = this.readLogFile(file);
			console.log(`  ${file}: ${entries.length} entries, ${this.formatBytes(stats.size)}, ${stats.mtime.toLocaleDateString()}`);
		});
	}

	listFiles() {
		const logFiles = this.getLogFiles();
		
		if (logFiles.length === 0) {
			console.log('No log files found.');
			return;
		}

		console.log('\n📁 Available Log Files:\n');
		
		logFiles.forEach((file, index) => {
			const filePath = path.join(this.logsDir, file);
			const stats = fs.statSync(filePath);
			const entries = this.readLogFile(file);
			
			console.log(`${index + 1}. ${file}`);
			console.log(`   Entries: ${entries.length}`);
			console.log(`   Size: ${this.formatBytes(stats.size)}`);
			console.log(`   Modified: ${stats.mtime.toLocaleString()}`);
			console.log('');
		});
	}

	viewFile(fileName) {
		if (!fileName) {
			console.log('Please specify a log file name.');
			console.log('Use "node scripts/logManager.js list" to see available files.');
			return;
		}

		const entries = this.readLogFile(fileName);
		
		if (entries.length === 0) {
			console.log(`No entries found in ${fileName}`);
			return;
		}

		console.log(`\n📄 Log Entries from ${fileName} (${entries.length} entries):\n`);

		entries.slice(-20).forEach(entry => { // Show last 20 entries
			const timestamp = new Date(entry.timestamp).toLocaleString();
			const status = entry.response ? entry.response.statusCode : 'ERROR';
			const responseTime = entry.response ? `${entry.response.responseTime}ms` : 'N/A';
			
			console.log(`[${timestamp}] ${entry.operation}.${entry.resource}`);
			console.log(`  ${entry.request.method} ${entry.request.url}`);
			console.log(`  Status: ${status}, Time: ${responseTime}`);
			
			if (entry.error) {
				console.log(`  ❌ Error: ${entry.error.message}`);
			}
			
			console.log('');
		});

		if (entries.length > 20) {
			console.log(`... showing last 20 of ${entries.length} entries`);
		}
	}

	searchLogs(criteria) {
		const logFiles = this.getLogFiles();
		let allEntries = [];

		for (const file of logFiles) {
			const entries = this.readLogFile(file);
			allEntries.push(...entries);
		}

		// Parse search criteria
		const searchCriteria = this.parseSearchCriteria(criteria);
		
		// Filter entries
		const results = allEntries.filter(entry => this.matchesCriteria(entry, searchCriteria));

		console.log(`\n🔍 Search Results (${results.length} matches):\n`);

		if (results.length === 0) {
			console.log('No matching entries found.');
			return;
		}

		results.slice(-50).forEach(entry => { // Show last 50 matches
			const timestamp = new Date(entry.timestamp).toLocaleString();
			const status = entry.response ? entry.response.statusCode : 'ERROR';
			
			console.log(`[${timestamp}] ${entry.operation}.${entry.resource} - ${status}`);
			console.log(`  ${entry.request.method} ${entry.request.url}`);
			
			if (entry.error) {
				console.log(`  ❌ ${entry.error.message}`);
			}
			
			console.log('');
		});

		if (results.length > 50) {
			console.log(`... showing last 50 of ${results.length} matches`);
		}
	}

	parseSearchCriteria(criteriaString) {
		const criteria = {};
		
		if (!criteriaString) {
			return criteria;
		}

		// Parse key=value pairs
		const pairs = criteriaString.split(',');
		
		for (const pair of pairs) {
			const [key, value] = pair.split('=').map(s => s.trim());
			
			switch (key) {
				case 'operation':
				case 'resource':
					criteria[key] = value;
					break;
				case 'status':
				case 'statusCode':
					criteria.statusCode = parseInt(value);
					break;
				case 'error':
				case 'hasError':
					criteria.hasError = value.toLowerCase() === 'true';
					break;
				case 'from':
					criteria.fromDate = new Date(value);
					break;
				case 'to':
					criteria.toDate = new Date(value);
					break;
			}
		}

		return criteria;
	}

	matchesCriteria(entry, criteria) {
		if (criteria.operation && entry.operation !== criteria.operation) {
			return false;
		}

		if (criteria.resource && entry.resource !== criteria.resource) {
			return false;
		}

		if (criteria.statusCode && entry.response?.statusCode !== criteria.statusCode) {
			return false;
		}

		if (criteria.hasError !== undefined) {
			const hasError = !!entry.error;
			if (criteria.hasError !== hasError) {
				return false;
			}
		}

		if (criteria.fromDate) {
			const entryDate = new Date(entry.timestamp);
			if (entryDate < criteria.fromDate) {
				return false;
			}
		}

		if (criteria.toDate) {
			const entryDate = new Date(entry.timestamp);
			if (entryDate > criteria.toDate) {
				return false;
			}
		}

		return true;
	}

	cleanupLogs(daysToKeep = 30) {
		const cutoffDate = new Date();
		cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
		
		const logFiles = this.getLogFiles();
		let deletedCount = 0;
		let deletedSize = 0;

		console.log(`\n🧹 Cleaning up logs older than ${daysToKeep} days...\n`);

		for (const file of logFiles) {
			const filePath = path.join(this.logsDir, file);
			try {
				const stats = fs.statSync(filePath);
				if (stats.mtime < cutoffDate) {
					console.log(`Deleting: ${file} (${this.formatBytes(stats.size)}, ${stats.mtime.toLocaleDateString()})`);
					fs.unlinkSync(filePath);
					deletedCount++;
					deletedSize += stats.size;
				}
			} catch (error) {
				console.warn(`Failed to process ${file}:`, error.message);
			}
		}

		console.log(`\n✅ Cleanup complete:`);
		console.log(`  Files deleted: ${deletedCount}`);
		console.log(`  Space freed: ${this.formatBytes(deletedSize)}`);
	}

	exportLogs(format = 'json', outputFile) {
		const logFiles = this.getLogFiles();
		let allEntries = [];

		for (const file of logFiles) {
			const entries = this.readLogFile(file);
			allEntries.push(...entries);
		}

		if (allEntries.length === 0) {
			console.log('No log entries to export.');
			return;
		}

		let exportData;
		let defaultFileName;

		switch (format.toLowerCase()) {
			case 'csv':
				exportData = this.exportToCsv(allEntries);
				defaultFileName = `spryker-logs-${new Date().toISOString().split('T')[0]}.csv`;
				break;
			case 'txt':
				exportData = this.exportToText(allEntries);
				defaultFileName = `spryker-logs-${new Date().toISOString().split('T')[0]}.txt`;
				break;
			case 'json':
			default:
				exportData = JSON.stringify(allEntries, null, 2);
				defaultFileName = `spryker-logs-${new Date().toISOString().split('T')[0]}.json`;
				break;
		}

		const fileName = outputFile || defaultFileName;
		const outputPath = path.resolve(fileName);

		try {
			fs.writeFileSync(outputPath, exportData, 'utf8');
			console.log(`\n📤 Exported ${allEntries.length} log entries to: ${outputPath}`);
			console.log(`   Format: ${format.toUpperCase()}`);
			console.log(`   Size: ${this.formatBytes(exportData.length)}`);
		} catch (error) {
			console.error('Failed to export logs:', error.message);
		}
	}

	exportToCsv(entries) {
		const headers = [
			'Timestamp',
			'Request ID',
			'Operation',
			'Resource',
			'Method',
			'URL',
			'Status Code',
			'Response Time',
			'Error',
		];

		const rows = entries.map(entry => [
			entry.timestamp,
			entry.requestId,
			entry.operation,
			entry.resource,
			entry.request.method,
			entry.request.url,
			entry.response?.statusCode || '',
			entry.response?.responseTime || '',
			entry.error?.message || '',
		]);

		return [headers, ...rows]
			.map(row => row.map(cell => `"${cell}"`).join(','))
			.join('\n');
	}

	exportToText(entries) {
		return entries.map(entry => {
			const lines = [
				`[${entry.timestamp}] ${entry.operation}.${entry.resource} (${entry.requestId})`,
				`  Request: ${entry.request.method} ${entry.request.url}`,
			];

			if (entry.response) {
				lines.push(`  Response: ${entry.response.statusCode} (${entry.response.responseTime}ms)`);
			}

			if (entry.error) {
				lines.push(`  Error: ${entry.error.message}`);
			}

			return lines.join('\n');
		}).join('\n\n');
	}

	formatBytes(bytes) {
		if (bytes === 0) return '0 Bytes';
		
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	}

	showHelp() {
		console.log(`
🔧 Spryker API Log Manager

Usage: node scripts/logManager.js [command] [options]

Commands:
  stats                           Show logging statistics
  list                           List all log files
  view <filename>                View entries from a specific log file
  search <criteria>              Search logs by criteria
  cleanup [days]                 Clean up logs older than specified days (default: 30)
  export [format] [filename]     Export logs (formats: json, csv, txt)
  help                           Show this help message

Search Criteria Examples:
  operation=get                  Find all GET operations
  resource=products              Find all product-related requests
  status=404                     Find all 404 responses
  error=true                     Find all requests with errors
  from=2023-08-19               Find requests from specific date
  operation=get,status=200       Multiple criteria (comma-separated)

Export Examples:
  node scripts/logManager.js export json my-logs.json
  node scripts/logManager.js export csv
  node scripts/logManager.js export txt logs.txt

Examples:
  node scripts/logManager.js stats
  node scripts/logManager.js view spryker-api-2023-08-19.json
  node scripts/logManager.js search "operation=get,status=404"
  node scripts/logManager.js cleanup 7
		`);
	}
}

// Main execution
function main() {
	const args = process.argv.slice(2);
	const command = args[0] || 'help';
	
	const logManager = new LogManager();

	switch (command) {
		case 'stats':
			logManager.showStats();
			break;
		case 'list':
			logManager.listFiles();
			break;
		case 'view':
			logManager.viewFile(args[1]);
			break;
		case 'search':
			logManager.searchLogs(args[1]);
			break;
		case 'cleanup':
			const days = parseInt(args[1]) || 30;
			logManager.cleanupLogs(days);
			break;
		case 'export':
			const format = args[1] || 'json';
			const outputFile = args[2];
			logManager.exportLogs(format, outputFile);
			break;
		case 'help':
		default:
			logManager.showHelp();
			break;
	}
}

if (require.main === module) {
	main();
}

module.exports = LogManager;
